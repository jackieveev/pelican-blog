Slug: 9dbc0971e6514a00b4f74ea43c70c3cf
Title: 理解原型和原型链的正确姿势✔
Tags: 原型, 原型链, 面向对象

对于<code>原型</code>和<code>原型链</code>，网上已经有不少的解释，但我还是想说下个人的理解，下面先从原型开始。

## 一、原型

### Q1: 什么是原型?

首先，我们停止用面向过程和面向对象的知识来想象原型。

JS是基于原型的语言，<strong>每个对象都有原型，原型自己本身也是一个对象，原型也有原型。</strong>如果你能理解这句话，这章结就可以直接跳过了。如果不理解也没关系，我们继续探讨。

这句话理解的难点就是专用名词太多，我们用通俗的词语替换一下：每个人都有父母，父母自己本身也是人，父母也有父母。这样是不是清晰一点？

因此，<strong>原型可以理解为一种关系描述，用来表示对象之间的联系。</strong>

### Q2: 原型有什么用?

假设我们要实现一个能说话机器人。在面向对象的世界里，我们会自然而然地编写一个Robot类，并且定义speak方法，所有Robot类衍生的实例都会复制speak方法到自己身上，因此每个实例都有了speak方法。

在JS中，原型能实现类似效果，但实现过程有所不同：<strong>原型会引用这些属性和方法，但不复制。</strong>严格来说，JS中并没有“类”这种东西，在最新的ES标准中加入的class关键字，其实是用原型模拟的语法糖。

原型就像是对象间签订的友好互助条约。举个通俗的例子，你一个项目需要JAVA，但你不会写怎么办？你想到了你的好朋友小明有这项技能，你找他帮忙完成。原型在这里中充当了关系连结的角色，所以强大的人脉关系很重要，甚至能少奋斗几十年。

![测试一哈](/theme/img/1541050381297626.gif "javascript 原型链 原型 前端 人脉关系")

### Q3: 原型怎么用?

你可以使用<code>new</code>关键词来调用函数，它会依照你定义的函数和<code>prototype</code>来<strong>生成一个对象</strong>。

    #!javascript
    function Robot(name) {
        // 在new调用时，函数中的this指向了生成的这个对象
        this.name = name
    }
    Robot.prototype.speak = function () {
        console.log('hello, i\'m ' + this.name)
    }

    const foo = new Robot('foo')
    foo.speak() // hello, i'm foo
    const bar = new Robot('bar')
    foo.speak === bar.speak // true

很多人会因此产生了JS有“类”的错觉，因为new在很多语言中都跟随着类出没的，这也导致了相当多的误解。为什么会有这种错觉？其实还是面向对象的思维作祟。类似的还有<code>\_\_proto\_\_</code>，这是一个<strong>非标准</strong>的属性，它指向了该对象的原型。初学者很容易产生<code>foo.\_\_proto\_\_ === Robot</code>这样的错觉，因为在面向对象的思维里，foo是Robot类的一个实例，我们理所当然地认为它们会存在某种派生关系，事实上在JS中这些关系稍显复杂。

    #!javascript
    // 沿用上方代码
    // __proto__是非标准属性，我们也可以用ES5的新方法Object.getPrototypeOf()
    foo.__proto__ === Robot.prototype // true
    foo.prototype.constructor === Robot // true
    foo.constructor === Robot // true

这里又有人疑惑了，为什么<code>foo.prototype.constructor === foo.constructor === Robot</code>？这其实只是一个美丽的误会，前面我们谈到你和小明的例子，你最终把项目完成了，小红表示很崇拜：你好厉害居然还会JAVA！这些你马上澄清：这是小明做的。于是你继续光荣地单身。

事实上，真相比这个更复杂，当你以为constructor是foo.prototype的时候，很抱歉，那也不是它的！

那到底是谁的？前面说过，原型也是一个对象，原型也可以有原型，foo.prototype没有constructor，所以它往自己的原型上去找，一路找到了Object.prototype，终于发现了constructor。foo自己没有constructor属性，但它也能访问到，这其实就是<code>原型链</code>。

## 二、原型链

如果你已经知道原型是什么，那么原型链的概念是不言而喻的。<strong>原型表示对象间的关系，原型也可以拥有原型，如此一层一层将方法和属性连接起来。对象除了自身的方法和属性外，还可以得到原型的方法和属性，也可以沿着原型层层追溯，得到链路上的方法和属性，这个关系网络就是原型链。</strong>

### 1、原型继承

对象能从原型链上得到额外的方法和属性，一般称为<code>原型继承</code>，很多人容易和面向对象中的继承混淆。正如前面所说，<strong>原型并不复制，只会简单地关联对象。</strong>对象自己没有这个方法和属性，它会去原型链上找，如果一路找到底还是没有就会返回<code>undefined</code>。

